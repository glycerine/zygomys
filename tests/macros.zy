(def l %(1 2 3))
(def b 4)

(assert (== ^(0 ~@l ~b) %(0 1 2 3 4)))

// note that we use ^ caret to start a template,
// as opposed to the traditional lisp `` backtick.
// This lets us use Go-style string literals that
// are demarcated by backticks.
(defmac when [predicate & body]
  ^(cond ~predicate
      (begin
        ~@body) %()))

(assert (null? (when false %c)))
(assert (== %a (when true %c %b %a)))

(def h (hash a:1 b:2))
// check that arrays and hashes are getting scanned for ~ syntax unquotes.
(defmac sizer [myHash] ^(let [n (len ~myHash) g (hash sz: (len ~myHash))] (+ n (:sz g))))
(assert (== (sizer h) 4))

// this shouldn't give an error, but it was: error in __main:5: Error on line 1: Unexpected end of input
(defn greet [name] ^(hello ~name))

// zygomys/issues/54 (gensym) in defmac giving same symbol
(assert (!= (gensym) (gensym)))
(defmac aaa [] (gensym) ^())
(aaa) // was causing gensym not to increment env.nextsymbol
(assert (!= (gensym) (gensym)))

// zygomys/issues/54 corner case, user wants macros to be able to arbitrarily alter
// the current environment.
(def myfunc "")
(def myout1 "")
(def myout2 "")
(defmac new1 [] (let [name (gensym "func")] (set myfunc name) ^(defn ~name [] (setq myout1 "function1"))))
(defmac new2 [] (let [name (gensym "func")] (set myfunc name) ^(defn ~name [] (setq myout2 "function2"))))
(new1)
(def prevfunc myfunc)
(printf "prevfunc is '%v'\n" (str prevfunc))
(new2)
(printf "myfunc is now '%v'\n" (str myfunc))
// assert that two different myfunc names were generated by the two different gensym invocations.
(assert (!= myfunc prevfunc))

