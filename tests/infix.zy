// infix will be contained within {}
(assert (== "list" (type? (macexpand {}))))
(assert (== "nil" (str (infix))))

(assert (== {3 + 4} 7))

{3 + 4}

(assert (== {9 - 8} 1))

(assert (== { 9 - {1 - 3}} 11))

(assert (== {4 + 2 * 3}  10))

(assert (== {4 - 4 / 2}  2))

(assert (== {3 * 2 ** 3}  24))

// and can mix in function calls to infix expressions
(defn f [] 7)
(assert (== -1020  {4 - 2 ** {3 + (f)}}))

(assert (== {true and not false} {not false and true and true}))

// can put infix as arguments to sexp calls
(defn add [a b] (+ a b))
(assert (== (add {4 + 1} {6 - 1}) 10))

//(def a [3 4 5])
//(assert (== "4" (str {a[1]})))
//(assert {a[1] == 4})

{ newvar = 3}
(assert (== newvar 3))

(assert (== {5 mod 3} 2))

{newvar++}
(assert (== newvar 4))
{newvar--}
(assert (== newvar 3))

// pow should be right associative
(assert (== {2 ** 3 ** 3} 134217728))

// lack of spacing between builtin operators should not matter,
// expect that -1 is preferred over subtract 1 so 6-1 won't parse.
(assert (== (add {4+1} {6 - 1}) 10))

// debug help: infixExpand shows the conversion from infix to s-expression
(assert (== "(quote (set a 4))" (str (infixExpand { a = 4})) ))

(assert (== {4/10} 0.4))

// comparisons
(assert (== true { 2 < 3}))
(assert (== true { 4 > 2}))

(assert (== true { 2 <= 2}))
(assert (== false { 3 <= 2}))
(assert (== true { 2 >= 2}))
(assert (== false { 1 >= 2}))

(assert (== true { 1 == 1}))
(assert (== true { 1 != 0}))

(assert (== "(quote (<= 2 3))" (str (infixExpand {2<=3})) ))
(assert {2 < 3})

(def h (hash a:(hash b:[12 4 6])))
(assert (== {h.a.b[0]} 12))
// (quote (arrayidx h.a.b [0]))

(infixExpand {h.a.b[2] = 99})
{h.a.b[2] = 99}
(assert (== {h.a.b[2]} 99))

// dot after array indexing
(def arr [(hash a:(hash b:[3 4]))])
(assert (== {arr[0].a.b[1]} 4))
(infixExpand {arr[0].a.b[0]})