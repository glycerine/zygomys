;; declare structs

(struct Car [
        (field Id:          int64     e:0                  gotags:`json:"id",name:"id"`)
        (field Name:        string    e:1                  gotags:`json:"name"`)
        (field BadApple:    string    e:2  deprecated:true)
        ])

;; redefines on the fly:
(struct Car [
        (field Id:          int64     e:0                  gotags:`json:"id",name:"id"`)
        (field Name:        string    e:1                  gotags:`json:"name"`)
        (field BadApple:    string    e:2  deprecated:true)
        (field SliceOfLife: ([] string)  e:3)
        (field PointerSisters: (* int64) e:4)
        (field OtherCar: (* Car) e:5)
        ])

(def p (Car Id: 99912))
(def r (Car OtherCar: (& p)))

(assert (==
         (* (& p))
         p
        )
   )

(def p1 (& p))
(def p2 (& p))

(assert (== p1 p2))

(def car2 (Car Id: 7))
(assert (!= (& car2) p1))
(assert (!= (& car2) p2))

(var a (* Car))
;; declares a zerotyped Car to be pointed at.
(expect-error "Error calling '*': illegal to dereference nil pointer" (assert (== (:Id (* a)) 0)))

(assert (== (type? a) "*Car"))
(a = (& p))
(assert (== (:Id (* a)) 99912))

(hasSlice = (Car SliceOfLife: ["hi" "there"]))
(assert (== (:SliceOfLife hasSlice) ["hi" "there"]))
(assert (== 2 (len (.hasSlice.SliceOfLife))))

(.hasSlice.SliceOfLife = [])
(assert (== 0 (len (.hasSlice.SliceOfLife))))

(.hasSlice.SliceOfLife = ["zygo" "rocks" "it"])
(assert (== 3 (.hasSlice.SliceOfLife len)))

(expect-error `Error calling '.hasSlice.NewField': Car has no field 'NewField'`
            (.hasSlice.NewField = "wacky"))

(expect-error `Error calling '.hasSlice.SliceOfLife': field Car.SliceOfLife is ([]string), cannot assign ([]int64) '[1 2 3]'`
              (.hasSlice.SliceOfLife = [1 2 3]))


;; nil for slices and pointers should be okay
(Car SliceOfLife:nil)
(Car OtherCar:nil)


;; not yet implemented stuff:

;; delcare functions
;; always using named return types; so we can
;; have an implicit return ending in the compile-down.
;;
;;(func doSomething [a:int b:string] [n:int err:error]
;;  (return a nil))
;;
;; declare interfaces
;; (interface Driveable [
;;      (func driveIt [a:int b:string] [n:int err:error])
;;   ])
;;
;; declare methods
;; (func [p: (* Car)] driveIt [a:int b:string] [n:int err:error])
