;; declare structs

(struct Car [
        (field Id:          int64     e:0                  gotags:`json:"id",name:"id"`)
        (field Name:        string    e:1                  gotags:`json:"name"`)
        (field BadApple:    string    e:2  deprecated:true)
        (field SliceOfLife: ([] string)  e:3)
        (field PointerSisters: (* int64) e:4)
        (field OtherCar: (* Car) e:5)
        ])

(def p (Car Id: 99912))
(def r (Car OtherCar: (& p)))

(assert (==
         (* (& p))
         p
        )
   )

(def p1 (& p))
(def p2 (& p))

(assert (== p1 p2))

(def car2 (Car Id: 7))
(assert (!= (& car2) p1))
(assert (!= (& car2) p2))

(var a (* Car))
;; declares a zerotyped Car to be pointed at.
(expect-error "Error calling '*': illegal to dereference nil pointer" (assert (== (:Id (* a)) 0)))

(assert (== (type? a) "*Car"))
(a = (& p))
(assert (== (:Id (* a)) 99912))
;; not yet implemented stuff:

;; delcare functions
;; always using named return types; so we can
;; have an implicit return ending in the compile-down.
;;
;;(func doSomething [a:int b:string] [n:int err:error]
;;  (return a nil))
;;
;; declare interfaces
;; (interface Driveable [
;;      (func driveIt [a:int b:string] [n:int err:error])
;;   ])
;;
;; declare methods
;; (func [p: (* Car)] driveIt [a:int b:string] [n:int err:error])
