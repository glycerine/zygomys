Zygomys: Embedded scripting toolkit for Go
16 March 2016

Jason E. Aten, Ph.D.
Principal Engineer, Betable.com
j.e.aten@gmail.com
@jasonaten_ 
https://github.com/glycerine/zygomys

* scenario

* Snoopy's areonautic adventures

.image snoopy_ace.png

* Curse you, Red Baron!

.image curse_you_red_baron.png

- imagine Snoopy comes back with friends...

* data model for a plane formation, a Go struct

.code snoopy1

- has an nested/embedded element, Plane

* Methods defined on the Snoopy struct

.code snoopy2

- anything that can Fly satifies the Flyer interface

* Flyer friends, can be listed in the Snoopy.Carrying slice

.code other.planes

* with the data model in mind, lets interact with it using zygo...

* zygomys -- what's in a name?

- zygo means union (yoke in Greek; the zygote was the first cell that was you).
- mys means mouse (Greek view of the bicep)
- this is a little mouse of a language
- bonus: there is a "pocket gopher" known as Zygogeomys trichopus. Our mascot.
- this is the union of lisp and Go. In a small cute package. 

* lexicon

- The mascot's name is Ziggy.
- Ziggy is a high-altitude pocket gopher. zygo aims to be a high-level control language.
- `zygomys` is the name for the language, `zygo` is the repl that implements the language.
- Let's agree to use the shorthand `zygo` when speaking to refer to the language and project. Its easier to say.
- I write out 'zygomys' for maximum search-ability (a unique search term). Moreover 'zygomys' is not trademarked.


* goals: learning and fun

- programming languages are fun!
- Lisp shows us: they don't have to be difficult to write
- particularly great context to learn about Test-driven design
- writing tests is trivial: write little language fragments

* fun

- Great for learning about interpreters, compilers, langauge structure.
- The whole project is a playground for experimentation. Evolve a design.
- I'll show you the architecture; take it and explore, try new stuff.

* Getting started How to embed the REPL in your code

See [[https://github.com/glycerine/zygomys/blob/master/cmd/zygo/main.go]]

.code main.go  /START OMIT/,/END OMIT/

that's it.


* overview

- explain overall architecture
- explain how to add a feature
- explain debug tools
- how to see what is happening

* if time

- I'll show the Go API/interface
- how to extend your language with a new function.
- lots of examples on github; the `github.com/gycerine/zygomys/repl/` directory is the central place.

* overview of design
- layers
- a) lexer produces tokens
- b) parser produces lists and arrays of symbols
- c) macros run at definition type
- d) codegen produces s-expression byte-code
- e) builders create and check types at `run` time. (Builders are a hybrid between a function and a macro.)
- f) vm executes s-expression byte-code


* philosophy
- interactive, but also enable compile-down to Go (eventual aim)
- blending Go and lisp
- I built it for myself

* interesting about the zygo/repl code itself
- using goroutines as coroutines to get pausable parsing
- if you haven't discovered how to do conditional sends on a channel yet, examples inside `github.com/glycerine/zygomys/repl/parser.go`.
   
* the hard parts that are already done

- script calls to existing Go functions using existing Go structs. Using reflect is somewhat laborious; but its done
- lexical scoping => closures that capture variables outside a function based on where that function was originally defined, as opposed to where it is called from.
- a repl-friendly linear time parser, avoiding the O(n*n) trap. (Uses go-routines as co-routines. inversion of receive loop)

* hard parts already done, part 2

- reflection based calls into Go code
- data structure for dynamic structs
- eval
- rudiments of a type system tries to match Go's type system.
- sandboxable / restrict outside access
- goroutines/channels/regexp (untouched since Glisp; not polished)

* use cases

- as a query language
- configuration language that can query itself.
- multi-core friendly scripting. Leverage Go's multicore strength for exploratory configuration, data analysis and scripting.
 
* the basic zygo->go function interface

.code first.go /START OMIT/,/END OMIT/

* why use an interpreter
- high personal productivity (examples: python, javascript, Matlab, R, Mathematica, lisp, scheme)
- fast feedback
- essential for exploratory data analysis 
- script your game/application
- become a language designer
- DSL creation: model a complex/dynamic problem, configure a complex/dynamic solution
- fun to write
- experiment with design


* side-effects

* perspective on TDD

- test-driven design is incredibly powerful at bringing up cross-layer issues.
- no where more apparent than in a very layered design like an interpreter/compiler. When you make a small language change in the lexer/parser, the test suite will tell what/if you've broken anything else.
- easily one of the most important techniques I've ever learned
- feel like you have super powers

- interpreter work really taught me the power of TDD
- TDD is not a test technique, its an design technique

- "To specify the server, write the client before the server."

* components

- s-expression: lexer and parser
- unification (for type-system and other); this is how parametric polymorphism could be implemented.
- repl. Read-eval-print-loop. an interactive prompt.

* infix and (infixExpand)

- infix: top-down operator precedence parser (Pratt parser; see Douglas Crockford's writings)

.code infix.txt


* major files of `github.com/glycerine/zygomys/repl/`

- repl.go        ...ReplMain() lives here, toplevel loop
- expression.go  ...the core Sexp s-expression definitions
- environment.go ...lexical scope, symbol table lookup
- lexer.go       ...hand written lexer
- parser.go      ...recursive parsing of symbols into lists and arrays
- generator.go   ...code-gen: generate Sexp byte code
- vm.go          ...virtual machine that executes the byte code
- builders.go    ...declarations and type checking
- gotypereg.go   ...the type registry for Go/zygo type correspondence

* auxilliary/helper files; also in `github.com/glycerine/zygomys/repl/`

- typeutils.go    ...runtime type inspection from zygo
- hashutils.go    ...records (a.k.a hash tables)
- listutils.go    ...linked list (*SexpPair) utilities
- strutils.go     ...string utilities
- scope.go        ...stack of symbol tables
- stack.go        ...used by scopes
- rawutils.go     ...raw []byte handling
- numerictower.go    number conversions
- vprint.go       ...debug print stuff for development

* custom types: extension example files

- random.go   (wrap math/rand.Float64() call)
- regexp.go   (wrap regexp.Regexp)
- time.go     (wrap time.Time)
- jsonmsgp.go (conversions to/from json and msgpack)

* internal Sexp types

.code exp.txt

- SexpNull (actually a value; an instance of the SexpSentinel type)
- SexpSymbol (symbol table entries)
- SexpPair   (linked lists)
- SexpArray  (slices)
- SexpHash   (hash table; keys and values are any Sexp, key ordering preserved)
`...`

* debug tools
- `.dump`
- `.debug`
- `.undebug`
- `.gls`
- `.ls`
- `(macexpand)`
- `(infixExpand {})`

* json / msgpack support

See the top of `github.com/glycerine/zygomys/repl/jsonmsgp.go` for a guide.

.code msgp.txt

* records

- easy to type
- define data with named fields
- hash tables with a name and a key-order


* hash maps

.code hash.demo

* arrays/slices

.code slice.demo

* arrays/slices

.code slice2.demo

* still todo

- optional static type system is half implemented
- struct declarations done, function type declarations with (func) not yet done.
- the static typing aims for compability with Go types (to enable dompile-down)
- see commented out sections of `github.com/glycerine/zygomys/tests/decl_fun.zy`

* still todo 2

- dataframe
- matrix / tensor types
- complex number support

* dreams

- model checking syntax and checker (OBDD based)
- port TLA+ model checker to Go, with zygomys interface
- unification engine for parametric polymorphism experiments
- inteface to Vowpow-Wabbit for psuedo online-SVD


* If you want to play with type systems

- try out your parametric-polymorphism idea?
- I don't know if its a good idea but...
- the sigil-system is setup to let you explore this area
- sigil prefixed symbols start with `$`, `#`, or `?`
- makes it easy to define type-variables, for example.


* sigil system

symbols with a special prefix

- `mysym` is a regular symbol
- `$mysym` is a sigil symbol, with sigil '$'. It is distinct from `mysym`.
- `#mysym` is a sigil symbol, with sigil '#'. It is distinct from `$mysym` and `mysym`.
- `?mysym` is a sigil symbol, with sigil '?'. It is distinct from the above.

* sigils part 2

- sigil prefixed-symbols evaluate to themselves by default.
- useful for grammars, symbolic reasoning.

* Pratt parsing : theory of operation for Top-down Operator Precedence parsing

- Like quicksort. A short, sharp algorithm. Not particularly easy to understand on the first pass.

- works like magic. Very easy to extend your language with new infix operations, once the core Expression routine is implemented. This is how zygo processes infix syntax.

- links for learning:

.link https://github.com/glycerine/zygomys/blob/master/repl/pratt.go Already written into zygo.

.link https://github.com/glycerine/PrattParserInC/blob/master/Vaughan.Pratt.TDOP.pdf original paper

.link http://javascript.crockford.com/tdop/tdop.html Douglas Crockford's article 

.link http://effbot.org/zone/simple-top-down-parsing.htm example in python 

.link http://journal.stuffwithstuff.com/2011/03/19/pratt-parsers-expression-parsing-made-easy/ example in Java 


* building zygo's static type system

- A builder is a special kind of function; a hybrdid between a function and a macro. I chose the term `builder` to reflect their ability to build structs (i.e. new types), packages, type aliases.

- Like a macro, a builder receives the un-evaluated parse-tree of symbols from its caller. A builder can therefore be used to build new types and declarations new functions/methods.

- Like a function, a builder is called at run/evaluation time, not at definition time. (Macros are run at code-gen, which is definition time).

- Since it receives an un-evaluated tree of symbols, a builder must manually evaluate any arguments it wishes to find bindings for in scope.

- Used in zygo to define structs. Next planned use: define interfaces, functions, methods, and type aliases. See [[https://github.com/glycerine/zygomys/blob/master/repl/builders.go]] for examples.

